<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ロードファイター風ゲーム（当たり判定分離版）</title>
<style>
  body { margin:0; overflow:hidden; background:#444; display:flex; justify-content:center; align-items:center; height:100vh; }
  canvas { display:block; background:#555; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// 仮想画面サイズ（縦16:9）
const V_WIDTH = 1080;
const V_HEIGHT = 1920;
let scale = 1, offsetX = 0, offsetY = 0;

// ==========================
// プレイヤー
// ==========================
const player = { 
    width: 120, 
    height: 240, 
    x: V_WIDTH/2, 
    y: V_HEIGHT - V_HEIGHT/5,
    // TODO [即対応]: ライフ管理追加
    life: 100
};

// ==========================
// 道路
// ==========================
const road = { width: V_WIDTH*0.6, curve: 0, curveTarget: 0, speed: 10 };

// ==========================
// 中央線
// ==========================
const LINE_LENGTH = 200;
const LINE_GAP = 100;
const centerLines = [];
for(let y=-LINE_LENGTH; y<V_HEIGHT; y+=LINE_LENGTH+LINE_GAP){
    centerLines.push({ y });
}

// ==========================
// 敵車
// ==========================
let obstacles = [];
const MAX_OBSTACLES = 4;
let nextSpawnTime = Date.now() + randomSpawnInterval();

// --- スポーン関数 ---
function randomSpawnInterval() {
    const options = [1000, 3000, 5000];
    return options[Math.floor(Math.random()*options.length)];
}
function randomObstacleSize() {
    const r = Math.random();
    if(r < 0.7) return { width: player.width, height: player.height };
    else if(r < 0.9) return { width: player.width/2, height: player.height/2 };
    else return { width: player.width, height: player.height*2 };
}
function randomObstacleSpeed() {
    const r = Math.random();
    if(r < 0.5) return road.speed;
    else if(r < 0.75) return road.speed + 2;
    else return road.speed - 2;
}
function roadLeftX() {
    const min = V_WIDTH*0.1;
    const max = V_WIDTH*0.9 - road.width;
    return Math.max(min, Math.min(max, V_WIDTH/2 - road.width/2 + road.curve));
}
function clampObstacleX(obs) {
    const roadX = roadLeftX();
    const margin = road.width * 0.05;
    const minX = roadX + margin;
    const maxX = roadX + road.width - margin - obs.width;
    obs.x = Math.max(minX, Math.min(maxX, obs.x));
}
function spawnObstacle() {
    const now = Date.now();
    if(obstacles.length >= MAX_OBSTACLES) return;
    if(now < nextSpawnTime) return;

    const size = randomObstacleSize();
    const speed = randomObstacleSpeed();
    const roadX = roadLeftX();

    const newObs = {
        x: roadX + Math.random()*(road.width - size.width),
        y: -size.height,
        width: size.width,
        height: size.height,
        speed: speed
    };
    clampObstacleX(newObs);
    obstacles.push(newObs);
    nextSpawnTime = now + randomSpawnInterval();

    // TODO [中期]: アイテム生成も同様にspawn関数で追加
}

// ==========================
// キー入力
// ==========================
const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

// ==========================
// カーブ処理
// ==========================
function updateRoadCurve() {
    if(Math.random() < 0.01) road.curveTarget = (Math.random()-0.5) * V_WIDTH * 0.8;
    road.curve += (road.curveTarget - road.curve) * 0.02;

    const left = V_WIDTH/2 - road.width/2 + road.curve;
    const min = V_WIDTH*0.1;
    const max = V_WIDTH*0.9 - road.width;
    if(left < min) road.curve += (min-left);
    if(left > max) road.curve -= (left-max);
}

// ==========================
// 当たり判定
// ==========================
// プレイヤー vs 敵（縮小）
function isCollidingPlayerEnemy(player, obs){
    const shrink = 0.85;
    const obsLeft = obs.x + obs.width*(1-shrink)/2;
    const obsRight = obsLeft + obs.width*shrink;
    const obsTop = obs.y + obs.height*(1-shrink)/2;
    const obsBottom = obsTop + obs.height*shrink;

    return (
        player.x - player.width/2 < obsRight &&
        player.x + player.width/2 > obsLeft &&
        player.y - player.height/2 < obsBottom &&
        player.y + player.height/2 > obsTop
    );
}

// 敵 vs 敵（拡大）
function isCollidingEnemyEnemy(a, b){
    const expand = 1.15;
    const aLeft = a.x - a.width*(expand-1)/2;
    const aRight = aLeft + a.width*expand;
    const aTop = a.y - a.height*(expand-1)/2;
    const aBottom = aTop + a.height*expand;

    return (
        b.x < aRight &&
        b.x + b.width > aLeft &&
        b.y < aBottom &&
        b.y + b.height > aTop
    );
}

// ==========================
// 敵車更新
// ==========================
function updateObstacles() {
    const marginY = player.height / 3;
    for(let i=0; i<obstacles.length; i++){
        let obs = obstacles[i];
        obs.y += obs.speed;
        clampObstacleX(obs);

        // 敵車同士の距離制御
        for(let j=0; j<i; j++){
            let prev = obstacles[j];
            if(isCollidingEnemyEnemy(obs, prev)){
                obs.speed = prev.speed;
            }
        }
    }
    while(obstacles.length && obstacles[0].y > V_HEIGHT) obstacles.shift();
}

// ==========================
// スコアとゲームオーバー
// ==========================
let score = 0;
let gameOver = false;

// TODO [即対応]: off-road判定でLP減少
function checkOffRoadLife() {
    const roadX = roadLeftX();
    if(player.x - player.width/2 < roadX || player.x + player.width/2 > roadX + road.width){
        player.life -= 1; // 100msタイマーで減少予定
        if(player.life <= 0) gameOver = true;
    }
}

// 更新
function update() {
    if(gameOver) return;

    updateRoadCurve();

    // プレイヤー移動
    if(keys['ArrowLeft']) player.x -= 12;
    if(keys['ArrowRight']) player.x += 12;
    const minX = V_WIDTH*0.05 + player.width/2;
    const maxX = V_WIDTH*0.95 - player.width/2;
    player.x = Math.max(minX, Math.min(maxX, player.x));

    updateObstacles();
    spawnObstacle();

    // 中央線スクロール
    centerLines.forEach(line=>{
        line.y += road.speed * 1.3; // 白線速度アップ
        if(line.y > V_HEIGHT) line.y = -LINE_LENGTH;
    });

    // スコア加算
    score++;

    // プレイヤーと敵車の衝突判定
    for(let obs of obstacles){
        if(isCollidingPlayerEnemy(player, obs)){
            // TODO [即対応]: 衝突時LP減少に変更（現在は即GAME OVER）
            player.life -= 50;
            if(player.life <= 0) gameOver = true;
        }
    }

    checkOffRoadLife(); // TODO [即対応]: off-roadライフ減少
}

// ==========================
// 描画
// ==========================
function draw() {
    ctx.save();
    ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
    ctx.clearRect(0,0,V_WIDTH,V_HEIGHT);

    const roadX = roadLeftX();
    ctx.fillStyle="#333";
    ctx.fillRect(roadX,0,road.width,V_HEIGHT);

    // 中央線
    ctx.strokeStyle="#fff";
    ctx.lineWidth=8;
    ctx.setLineDash([LINE_LENGTH,LINE_GAP]);
    ctx.beginPath();
    centerLines.forEach(line=>{
        const centerX = roadX+road.width/2;
        ctx.moveTo(centerX, line.y);
        ctx.lineTo(centerX, line.y+LINE_LENGTH);
    });
    ctx.stroke();
    ctx.setLineDash([]);

    // 敵車
    ctx.fillStyle="red";
    obstacles.forEach(obs=>ctx.fillRect(obs.x, obs.y, obs.width, obs.height));

    // プレイヤー
    ctx.fillStyle="blue";
    ctx.fillRect(player.x-player.width/2, player.y-player.height/2, player.width, player.height);

    // スコア表示
    ctx.fillStyle="white";
    ctx.font="bold 60px sans-serif";
    ctx.fillText("SCORE: " + score, 40, 80);

    // ライフバー表示
    ctx.fillStyle="green";
    ctx.fillRect(40,120,player.life*8,40); // 仮: LP 100なら幅800

    if(gameOver){
        ctx.fillStyle="rgba(0,0,0,0.7)";
        ctx.fillRect(0,0,V_WIDTH,V_HEIGHT);
        ctx.fillStyle="yellow";
        ctx.font="bold 120px sans-serif";
        ctx.fillText("GAME OVER", V_WIDTH/2-300, V_HEIGHT/2);
        // TODO [即対応]: 再スタートUI表示
    }

    ctx.restore();
}

// ==========================
// ループ
// ==========================
function loop(){ update(); draw(); requestAnimationFrame(loop); }
loop();

// ==========================
// リサイズ
// ==========================
function resizeCanvas(){
    const windowRatio = window.innerWidth/window.innerHeight;
    const gameRatio = V_WIDTH/V_HEIGHT;
    if(windowRatio > gameRatio){
        scale = window.innerHeight/V_HEIGHT;
        canvas.width = V_WIDTH*scale;
        canvas.height = V_HEIGHT*scale;
        offsetX = (window.innerWidth - canvas.width)/2;
        offsetY = 0;
    } else {
        scale = window.innerWidth/V_WIDTH;
        canvas.width = V_WIDTH*scale;
        canvas.height = V_HEIGHT*scale;
        offsetX = 0;
        offsetY = (window.innerHeight - canvas.height)/2;
    }
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ==========================
// TODO一覧（組み込みコメント版）
// ==========================
// [即対応]
// - ライフ管理（LP）実装
// - off-road 100msタイマーで減少
// - 衝突時ライフ減少に変更
// - 再スタートUIの作成
// [中期]
// - タッチ操作追加（左右スワイプ/ボタン）
// - アイテム取得実装
// - BGM/SFX プリロード、ユーザー操作で再生開始
// - カーブ挙動微調整
// - 敵車行動パターン拡張
// [磨き込み]
// - スプライト差し替え（プレイヤー/敵車/アイテム）
// - 衝突エフェクト
// - UI改善（ライフバー/スコアバー位置やデザイン）
// - 難易度曲線調整
// - パフォーマンス最適化（オフスクリーンCanvas、描画順）


</script>
</body>
</html>
