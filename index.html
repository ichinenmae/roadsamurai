// é€†èµ°è»Šã®è­¦å‘Šæç”»
    function drawReverseWarnings() {
      for (const warning of game.reverseWarnings) {
        // 200msã”ã¨ã«ç‚¹æ»…
        const shouldShow = Math.floor(warning.blinkTimer / 200) % 2 === 0;
        
        if (shouldShow) {
          const warningY = V_HEIGHT - 150;  // ç”»é¢ä¸‹éƒ¨ã«è¡¨ç¤º
          
          // èµ¤ã„â–¼ãƒãƒ¼ã‚¯
          ctx.fillStyle = '#f00';
          ctx.beginPath();
          ctx.moveTo(warning.x, warningY);
          ctx.lineTo(warning.x - 20, warningY - 30);
          ctx.lineTo(warning.x + 20, warningY - 30);
          ctx.closePath();
          ctx.fill();
          
          // è­¦å‘Šæ–‡å­—
          ctx.fillStyle = '#ff0';
          ctx.font = 'bold 18px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('!', warning.x, warningY - 10);
        }
      }
    }    // é€†èµ°è»Šã®è­¦å‘Šæ›´æ–°
    function updateReverseWarnings(deltaTime) {
      const now = Date.now();
      
      // è­¦å‘Šã®ç‚¹æ»…ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
      for (const warning of game.reverseWarnings) {
        warning.blinkTimer += deltaTime;
      }
      
      // å‡ºç¾æ™‚åˆ»ã‚’éããŸè­¦å‘Šã‚’å‰Šé™¤
      game.reverseWarnings = game.reverseWarnings.filter(w => w.spawnTime > now);
    }<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>ãƒ•ãƒ¼ãƒ‰ãƒ‡ãƒªãƒãƒªãƒ¼ãƒ¬ãƒ¼ã‚¹</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    body {
      width: 100%;
      height: 100%;
      position: fixed;
      top: 0;
      left: 0;
      overflow: hidden;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Arial', sans-serif;
      touch-action: none;
    }
    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      background: #87CEEB;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    #touchControls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      z-index: 1000;
    }
    #touchControls.active {
      display: grid;
      grid-template-columns: 80px 80px 80px;
      grid-template-rows: 80px 80px;
      gap: 20px;
      align-items: center;
      justify-items: center;
    }
    .touch-btn {
      width: 80px;
      height: 80px;
      background: rgba(255, 255, 255, 0.3);
      border: 3px solid rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      color: white;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      user-select: none;
      cursor: pointer;
      transition: background 0.1s;
    }
    .touch-btn:active {
      background: rgba(255, 255, 255, 0.5);
    }
    #btnUp {
      grid-column: 2;
      grid-row: 1;
    }
    #btnLeft {
      grid-column: 1;
      grid-row: 2;
    }
    #btnDown {
      grid-column: 2;
      grid-row: 2;
    }
    #btnRight {
      grid-column: 3;
      grid-row: 2;
    }
    #startScreen, #gameOverScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 2000;
    }
    #startScreen h1, #gameOverScreen h1 {
      font-size: 48px;
      margin-bottom: 20px;
      text-shadow: 0 4px 8px rgba(0,0,0,0.8);
    }
    #startScreen p, #gameOverScreen p {
      font-size: 20px;
      margin-bottom: 30px;
      text-align: center;
      padding: 0 20px;
    }
    .btn {
      padding: 15px 40px;
      font-size: 24px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: background 0.3s;
    }
    .btn:hover {
      background: #45a049;
    }
    .btn:active {
      transform: translateY(2px);
    }
    #gameOverScreen {
      display: none;
    }
    #finalScore {
      font-size: 36px;
      color: #FFD700;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="720" height="1280"></canvas>
  
  <div id="touchControls">
    <div class="touch-btn" id="btnUp">â–²</div>
    <div class="touch-btn" id="btnLeft">â—„</div>
    <div class="touch-btn" id="btnDown">â–¼</div>
    <div class="touch-btn" id="btnRight">â–º</div>
  </div>

  <div id="startScreen">
    <h1>ğŸï¸ ãƒ•ãƒ¼ãƒ‰ãƒ‡ãƒªãƒãƒªãƒ¼</h1>
    <p>é…é”ãƒã‚¤ã‚¯ã‚’æ“ä½œã—ã¦éšœå®³ç‰©ã‚’é¿ã‘ã‚ˆã†ï¼<br>é“è·¯ã‹ã‚‰å¤–ã‚Œã‚‹ã¨ãƒ©ã‚¤ãƒ•ãŒæ¸›å°‘ã—ã¾ã™</p>
    <button class="btn" id="btnStart">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
  </div>

  <div id="gameOverScreen">
    <h1>GAME OVER</h1>
    <div id="finalScore">ã‚¹ã‚³ã‚¢: 0</div>
    <button class="btn" id="btnRestart">ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const V_WIDTH = 720;
    const V_HEIGHT = 1280;
    
    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    const game = {
      score: 0,
      life: 100,
      gameOver: false,
      started: false,
      obstacles: [],
      nextSpawnTime: 0,
      offRoadTimer: 0,
      speedMultiplier: 1,
      distanceTraveled: 0,
      reverseWarnings: []  // é€†èµ°è»Šã®å‡ºç¾äºˆå‘Š
    };

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š
    const player = {
      x: V_WIDTH / 2,
      y: V_HEIGHT * 0.8,
      width: V_WIDTH * 0.11,
      height: V_HEIGHT * 0.125,
      speed: 6,
      moveLeft: false,
      moveRight: false,
      currentSpeed: 9,  // ç¾åœ¨ã®é€Ÿåº¦ï¼ˆã‚²ãƒ¼ãƒ å†…é€Ÿåº¦ï¼‰
      targetSpeed: 9,   // ç›®æ¨™é€Ÿåº¦
      speedKmh: 60,     // è¡¨ç¤ºç”¨é€Ÿåº¦ï¼ˆkm/hï¼‰
      acceleration: 0.15  // åŠ é€Ÿåº¦
    };

    // é“è·¯è¨­å®š
    const road = {
      width: V_WIDTH * 0.6,
      curveTarget: 0,
      curveCurrent: 0,
      centerLineY: -200,  // åˆæœŸä½ç½®ã‚’ä¸Šã«ãšã‚‰ã—ã¦è‡ªç„¶ã«æµã‚Œå§‹ã‚ã‚‹
      centerLineGap: 100,
      centerLineLength: 200
    };

    // UIè¨­å®š
    const UI_HEIGHT = V_HEIGHT * 0.2;

    // éšœå®³ç‰©ã‚µã‚¤ã‚ºå®šç¾©
    const obstacleTypes = [
      { probability: 0.70, width: player.width, height: player.height },
      { probability: 0.20, width: player.width * 0.5, height: player.height * 0.5 },
      { probability: 0.10, width: player.width, height: player.height * 2 }
    ];

    // å…¥åŠ›ç®¡ç†
    const keys = {};
    let touchLeftActive = false;
    let touchRightActive = false;
    let touchUpActive = false;
    let touchDownActive = false;

    // é“è·¯å·¦ç«¯Xåº§æ¨™ã‚’è¨ˆç®—
    function roadLeftX() {
      return (V_WIDTH - road.width) / 2 + road.curveCurrent;
    }

    // é“è·¯å³ç«¯Xåº§æ¨™ã‚’è¨ˆç®—
    function roadRightX() {
      return roadLeftX() + road.width;
    }

    // éšœå®³ç‰©ã‚’é“è·¯å†…ã«ã‚¯ãƒ©ãƒ³ãƒ—
    function clampObstacleX(obs) {
      const margin = road.width * 0.05;
      const leftBound = roadLeftX() + margin;
      const rightBound = roadRightX() - margin;
      
      obs.x = Math.max(leftBound + obs.width / 2, Math.min(rightBound - obs.width / 2, obs.x));
    }

    // éšœå®³ç‰©ç”Ÿæˆï¼ˆé€†èµ°è»Šã®äºˆå‘Šä»˜ãï¼‰
    function spawnObstacle() {
      const rand = Math.random();
      let cumProb = 0;
      let chosenType = obstacleTypes[0];
      
      for (const type of obstacleTypes) {
        cumProb += type.probability;
        if (rand <= cumProb) {
          chosenType = type;
          break;
        }
      }

      // é€Ÿåº¦è¨­å®šï¼ˆé“è·¯åŸºæº–é€Ÿåº¦ã®50%, +25%, -25%ï¼‰
      const baseSpeed = 4 * game.speedMultiplier;
      const speedRand = Math.random();
      let speed;
      if (speedRand < 0.5) speed = baseSpeed;
      else if (speedRand < 0.75) speed = baseSpeed + 2;
      else speed = baseSpeed - 2;

      const willBeReverse = Math.random() < 0.07;  // é€†èµ°è»Šåˆ¤å®šã‚’å…ˆã«

      const obs = {
        x: roadLeftX() + road.width / 2,
        y: willBeReverse ? V_HEIGHT + chosenType.height + 100 : -chosenType.height - 100,
        width: chosenType.width,
        height: chosenType.height,
        speed: willBeReverse ? -(Math.abs(speed) + 3) : Math.max(2, speed),
        canChangeLane: !willBeReverse && Math.random() < 0.15,
        laneChangeTarget: null,
        laneChangeSpeed: 0,
        isReverse: willBeReverse
      };

      // é‡ãªã‚Šå›é¿ï¼ˆæœ€å¤§30å›è©¦è¡Œï¼‰
      let attempts = 0;
      let valid = false;
      
      while (attempts < 30 && !valid) {
        // ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã‚’ç”Ÿæˆ
        obs.x = roadLeftX() + road.width * (0.2 + Math.random() * 0.6);
        clampObstacleX(obs);
        
        valid = true;
        
        // æ—¢å­˜ã®å…¨éšœå®³ç‰©ã¨ã®é‡ãªã‚Šãƒã‚§ãƒƒã‚¯ï¼ˆåŒã˜æ–¹å‘ã®è»Šã®ã¿ï¼‰
        for (const other of game.obstacles) {
          // é€†èµ°è»Šã¯é€†èµ°è»ŠåŒå£«ã®ã¿ã€é€šå¸¸è»Šã¯é€šå¸¸è»ŠåŒå£«ã®ã¿ãƒã‚§ãƒƒã‚¯
          if (obs.isReverse !== other.isReverse) continue;
          
          // Yè»¸æ–¹å‘ã®è·é›¢ãƒã‚§ãƒƒã‚¯
          const verticalDistance = Math.abs(obs.y - other.y);
          const minVerticalGap = Math.max(obs.height, other.height) * 2.0;
          
          if (verticalDistance < minVerticalGap) {
            // æ°´å¹³æ–¹å‘ã®è·é›¢ã‚‚ãƒã‚§ãƒƒã‚¯
            const horizontalDistance = Math.abs(obs.x - other.x);
            const minHorizontalGap = (obs.width + other.width) / 2 + 30;
            
            if (horizontalDistance < minHorizontalGap) {
              valid = false;
              break;
            }
          }
          
          // é€šå¸¸ã®å½“ãŸã‚Šåˆ¤å®šã§ã‚‚ãƒã‚§ãƒƒã‚¯
          if (isCollidingEnemyEnemy(obs, other)) {
            valid = false;
            break;
          }
        }
        attempts++;
      }

      // æœ‰åŠ¹ãªä½ç½®ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã®ã¿è¿½åŠ 
      if (valid) {
        // é€†èµ°è»Šã®å ´åˆã¯1ç§’å‰ã«äºˆå‘Šã‚’è¿½åŠ 
        if (obs.isReverse) {
          game.reverseWarnings.push({
            x: obs.x,
            spawnTime: Date.now() + 1000,  // 1ç§’å¾Œã«å‡ºç¾
            blinkTimer: 0
          });
          // å®Ÿéš›ã®è»Šã¯1ç§’å¾Œã«è¿½åŠ ï¼ˆã‚¿ã‚¤ãƒãƒ¼ã§ç®¡ç†ï¼‰
          setTimeout(() => {
            game.obstacles.push(obs);
          }, 1000);
        } else {
          // é€šå¸¸è»Šã¯å³åº§ã«è¿½åŠ 
          game.obstacles.push(obs);
        }
      }
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨éšœå®³ç‰©ã®å½“ãŸã‚Šåˆ¤å®šï¼ˆã‚¹ã‚±ãƒ¼ãƒ«0.85 - å°ã•ã‚ï¼‰
    function isCollidingPlayerEnemy(p, e) {
      const scale = 0.85;
      const pw = p.width * scale;
      const ph = p.height * scale;
      const ew = e.width * scale;
      const eh = e.height * scale;
      
      return !(
        p.x + pw / 2 < e.x - ew / 2 ||
        p.x - pw / 2 > e.x + ew / 2 ||
        p.y + ph / 2 < e.y - eh / 2 ||
        p.y - ph / 2 > e.y + eh / 2
      );
    }

    // éšœå®³ç‰©åŒå£«ã®å½“ãŸã‚Šåˆ¤å®šï¼ˆã‚¹ã‚±ãƒ¼ãƒ«1.3 - å¤§ãã‚ï¼‰
    function isCollidingEnemyEnemy(a, b) {
      const scale = 1.3;  // 1.15ã‹ã‚‰1.3ã«æ‹¡å¤§
      const aw = a.width * scale;
      const ah = a.height * scale;
      const bw = b.width * scale;
      const bh = b.height * scale;
      
      return !(
        a.x + aw / 2 < b.x - bw / 2 ||
        a.x - aw / 2 > b.x + bw / 2 ||
        a.y + ah / 2 < b.y - bh / 2 ||
        a.y - ah / 2 > b.y + bh / 2
      );
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé“è·¯ä¸Šã«ã„ã‚‹ã‹åˆ¤å®š
    function isPlayerOnRoad() {
      const leftBound = roadLeftX();
      const rightBound = roadRightX();
      const playerLeft = player.x - player.width / 2;
      const playerRight = player.x + player.width / 2;
      
      return playerRight > leftBound && playerLeft < rightBound;
    }

    // é€†èµ°è»Šã®è­¦å‘Šæ›´æ–°
    function updateReverseWarnings(deltaTime) {
      const now = Date.now();
      
      // è­¦å‘Šã®ç‚¹æ»…ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
      for (const warning of game.reverseWarnings) {
        warning.blinkTimer += deltaTime;
      }
      
      // å‡ºç¾æ™‚åˆ»ã‚’éããŸè­¦å‘Šã‚’å‰Šé™¤
      game.reverseWarnings = game.reverseWarnings.filter(w => w.spawnTime > now);
    }

    // é“è·¯ã‚«ãƒ¼ãƒ–æ›´æ–°
    function updateRoadCurve() {
      // ãƒ©ãƒ³ãƒ€ãƒ ã«ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå¤‰æ›´
      if (Math.random() < 0.01) {
        road.curveTarget = (Math.random() - 0.5) * V_WIDTH * 0.4;
      }
      
      // ã‚¹ãƒ ãƒ¼ã‚ºã«è¿½å¾“
      road.curveCurrent += (road.curveTarget - road.curveCurrent) * 0.02;
      
      // é“è·¯ãŒç”»é¢å¤–ã«å‡ºãªã„ã‚ˆã†åˆ¶é™
      const maxCurve = V_WIDTH * 0.15;
      road.curveCurrent = Math.max(-maxCurve, Math.min(maxCurve, road.curveCurrent));
      
      // ä¸­å¤®ç·šã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
      road.centerLineY += 12 * game.speedMultiplier;  // 8 * 1.5 = 12
      if (road.centerLineY > road.centerLineLength + road.centerLineGap) {
        road.centerLineY = 0;
      }
    }

    // éšœå®³ç‰©æ›´æ–°
    function updateObstacles(deltaTime) {
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é€Ÿåº¦ã«åŸºã¥ãç›¸å¯¾é€Ÿåº¦è¨ˆç®—
      const speedRatio = player.currentSpeed / 9;  // å·¡èˆªé€Ÿåº¦(9)ã‚’åŸºæº–
      
      // ç§»å‹•
      for (const obs of game.obstacles) {
        obs.y += obs.speed * game.speedMultiplier * speedRatio;
        
        // è»Šç·šå¤‰æ›´å‡¦ç†ï¼ˆé€†èµ°è»Šã¯è»Šç·šå¤‰æ›´ã—ãªã„ï¼‰
        if (obs.canChangeLane && !obs.isReverse) {
          // ç”»é¢å†…ã«å…¥ã£ã¦ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã§è»Šç·šå¤‰æ›´ã‚’é–‹å§‹
          if (obs.y > 100 && obs.y < V_HEIGHT - 300 && obs.laneChangeTarget === null && Math.random() < 0.005) {
            // å·¦å³ã©ã¡ã‚‰ã‹ã«ãƒ©ãƒ³ãƒ€ãƒ ã§ç§»å‹•
            const direction = Math.random() < 0.5 ? -1 : 1;
            const changeAmount = road.width * 0.25 * direction;
            obs.laneChangeTarget = obs.x + changeAmount;
            obs.laneChangeSpeed = 2;  // è»Šç·šå¤‰æ›´é€Ÿåº¦
          }
          
          // è»Šç·šå¤‰æ›´å®Ÿè¡Œ
          if (obs.laneChangeTarget !== null) {
            const diff = obs.laneChangeTarget - obs.x;
            if (Math.abs(diff) < obs.laneChangeSpeed) {
              obs.x = obs.laneChangeTarget;
              obs.laneChangeTarget = null;
            } else {
              obs.x += Math.sign(diff) * obs.laneChangeSpeed;
            }
          }
        }
        
        // é“è·¯ã‚«ãƒ¼ãƒ–ã«è¿½å¾“
        const roadCenter = roadLeftX() + road.width / 2;
        obs.x += (roadCenter - (roadLeftX() + road.width / 2)) * 0.5;
        clampObstacleX(obs);
      }

      // éšœå®³ç‰©åŒå£«ã®è¡çªå›é¿ï¼ˆé€Ÿåº¦èª¿æ•´ï¼‰- ç”»é¢å†…å¤–ä¸¡æ–¹ã§åˆ¤å®š
      for (let i = 0; i < game.obstacles.length; i++) {
        for (let j = i + 1; j < game.obstacles.length; j++) {
          const a = game.obstacles[i];
          const b = game.obstacles[j];
          
          // å½“ãŸã‚Šåˆ¤å®šã§ã®æ¥è§¦ãƒã‚§ãƒƒã‚¯ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«1.3ã§å¤§ãã‚ã«åˆ¤å®šï¼‰
          // é€†èµ°è»ŠåŒå£«ã¾ãŸã¯é€†èµ°è»Šã¨é€šå¸¸è»Šã¯è¡çªåˆ¤å®šã—ãªã„
          if (isCollidingEnemyEnemy(a, b) && !(a.isReverse || b.isReverse)) {
            // ä¸‹å´ï¼ˆå¾Œç¶šï¼‰ã®éšœå®³ç‰©ã‚’ä¸Šå´ï¼ˆå…ˆè¡Œï¼‰ã®é€Ÿåº¦ã«åˆã‚ã›ã‚‹
            if (a.y > b.y) {
              a.speed = b.speed;  // aãŒä¸‹å´ãªã®ã§bã®é€Ÿåº¦ã«åˆã‚ã›ã‚‹
            } else if (b.y > a.y) {
              b.speed = a.speed;  // bãŒä¸‹å´ãªã®ã§aã®é€Ÿåº¦ã«åˆã‚ã›ã‚‹
            }
          }
          
          // ç”»é¢å¤–ã§ã®è¿½åŠ ã®è·é›¢èª¿æ•´ï¼ˆé€†èµ°è»Šã¯é™¤å¤–ï¼‰
          if ((a.y < 0 || b.y < 0) && !(a.isReverse || b.isReverse)) {
            const verticalDistance = Math.abs(a.y - b.y);
            const horizontalDistance = Math.abs(a.x - b.x);
            const minGap = Math.max(a.height, b.height) * 1.5;
            
            if (verticalDistance < minGap && horizontalDistance < road.width * 0.5) {
              // ä¸‹å´ã®è»Šã‚’æ¸›é€Ÿ
              if (a.y > b.y) {
                a.speed = Math.max(1, b.speed - 0.5);
              } else {
                b.speed = Math.max(1, a.speed - 0.5);
              }
            }
          }
        }
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è¡çªåˆ¤å®šï¼ˆé€Ÿåº¦ã«ã‚ˆã£ã¦ãƒ€ãƒ¡ãƒ¼ã‚¸å¤‰åŒ–ï¼‰
      for (const obs of game.obstacles) {
        if (isCollidingPlayerEnemy(player, obs)) {
          // é€Ÿåº¦ã«ã‚ˆã£ã¦ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å¤‰æ›´
          let damage = 50;  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆå·¡èˆªï¼‰
          if (player.speedKmh >= 80) {
            damage = 75;  // é«˜é€Ÿ
          } else if (player.speedKmh <= 40) {
            damage = 25;  // ä½é€Ÿãƒ»åœæ­¢
          }
          
          game.life = Math.max(0, game.life - damage);
          // è¡çªã—ãŸéšœå®³ç‰©ã‚’å‰Šé™¤
          game.obstacles = game.obstacles.filter(o => o !== obs);
          
          if (game.life <= 0) {
            gameOver();
          }
          break;
        }
      }

      // ç”»é¢å¤–ã®éšœå®³ç‰©ã‚’å‰Šé™¤ï¼ˆé€†èµ°è»Šã‚‚è€ƒæ…®ï¼‰
      game.obstacles = game.obstacles.filter(obs => {
        if (obs.isReverse) {
          // é€†èµ°è»Šã¯ç”»é¢ä¸Šã«æ¶ˆãˆãŸã‚‰å‰Šé™¤
          return obs.y > -obs.height - 100;
        } else {
          // é€šå¸¸è»Šã¯ä¸Šä¸‹ä¸¡æ–¹ã§å‰Šé™¤
          return obs.y > -300 && obs.y < V_HEIGHT + obs.height;
        }
      });

      // æ–°è¦ç”Ÿæˆ
      const now = Date.now();
      if (now >= game.nextSpawnTime && game.obstacles.length < 4) {
        // ç”»é¢å¤–ã®é€šå¸¸è»Šã¨é€†èµ°è»Šã‚’ãã‚Œãã‚Œã‚«ã‚¦ãƒ³ãƒˆ
        const offscreenNormal = game.obstacles.filter(o => !o.isReverse && o.y < 0).length;
        const offscreenReverse = game.obstacles.filter(o => o.isReverse && o.y > V_HEIGHT).length;
        
        // é€šå¸¸è»Šã¯ç”»é¢å¤–ã«2å°æœªæº€ã€é€†èµ°è»Šã¯1å°æœªæº€ãªã‚‰ç”Ÿæˆå¯èƒ½
        if (offscreenNormal < 2 || offscreenReverse < 1) {
          spawnObstacle();
        }
        
        const spawnIntervals = [1500, 2500, 4000];  // é–“éš”ã‚’å°‘ã—åºƒã’ã‚‹
        const nextInterval = spawnIntervals[Math.floor(Math.random() * spawnIntervals.length)];
        game.nextSpawnTime = now + Math.max(1500, nextInterval);
      }
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ›´æ–°
    function updatePlayer() {
      // é€Ÿåº¦å¤‰æ›´å…¥åŠ›
      if (keys['ArrowUp'] || touchUpActive) {
        // åŠ é€Ÿï¼ˆæ¬¡ã®æ®µéšã¸ï¼‰
        if (player.targetSpeed === 0) player.targetSpeed = 6;
        else if (player.targetSpeed === 6) player.targetSpeed = 9;
        else if (player.targetSpeed === 9) player.targetSpeed = 12;
      }
      if (keys['ArrowDown'] || touchDownActive) {
        // æ¸›é€Ÿï¼ˆå‰ã®æ®µéšã¸ï¼‰
        if (player.targetSpeed === 12) player.targetSpeed = 9;
        else if (player.targetSpeed === 9) player.targetSpeed = 6;
        else if (player.targetSpeed === 6) player.targetSpeed = 0;
      }
      
      // é€Ÿåº¦ã‚’ç›®æ¨™ã«å‘ã‘ã¦é€£ç¶šçš„ã«å¤‰åŒ–
      if (player.currentSpeed < player.targetSpeed) {
        player.currentSpeed = Math.min(player.targetSpeed, player.currentSpeed + player.acceleration);
      } else if (player.currentSpeed > player.targetSpeed) {
        player.currentSpeed = Math.max(player.targetSpeed, player.currentSpeed - player.acceleration);
      }
      
      // km/hè¡¨ç¤ºç”¨ã«å¤‰æ›
      if (player.currentSpeed >= 11.5) player.speedKmh = 80;
      else if (player.currentSpeed >= 7.5) player.speedKmh = Math.round((player.currentSpeed / 9) * 60);
      else if (player.currentSpeed >= 3) player.speedKmh = Math.round((player.currentSpeed / 6) * 40);
      else if (player.currentSpeed > 0) player.speedKmh = Math.round((player.currentSpeed / 6) * 40);
      else player.speedKmh = 0;
      
      // å·¦å³ç§»å‹•
      if (keys['ArrowLeft'] || touchLeftActive) {
        player.x -= player.speed;
      }
      if (keys['ArrowRight'] || touchRightActive) {
        player.x += player.speed;
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ç”»é¢å†…ã«åˆ¶é™
      const minX = V_WIDTH * 0.05 + player.width / 2;
      const maxX = V_WIDTH * 0.95 - player.width / 2;
      player.x = Math.max(minX, Math.min(maxX, player.x));
    }

    // ãƒ©ã‚¤ãƒ•æ›´æ–°
    function updateLife(deltaTime) {
      if (!isPlayerOnRoad()) {
        game.offRoadTimer += deltaTime;
        if (game.offRoadTimer >= 100) {
          game.life = Math.max(0, game.life - 1);
          game.offRoadTimer = 0;
          
          if (game.life <= 0) {
            gameOver();
          }
        }
      } else {
        game.offRoadTimer = 0;
      }
    }

    // ã‚¹ã‚³ã‚¢æ›´æ–°
    function updateScore() {
      game.score += 1;
      game.distanceTraveled += 1;
      
      // é›£æ˜“åº¦ä¸Šæ˜‡
      if (game.distanceTraveled % 1000 === 0) {
        game.speedMultiplier = Math.min(2.0, game.speedMultiplier + 0.1);
      }
    }

    // èƒŒæ™¯æç”»
    function drawBackground() {
      // ç©º
      ctx.fillStyle = '#87CEEB';
      ctx.fillRect(0, 0, V_WIDTH, V_HEIGHT);
      
      // åœ°é¢ï¼ˆé“è·¯å¤–ï¼‰
      ctx.fillStyle = '#2d5016';
      ctx.fillRect(0, UI_HEIGHT, V_WIDTH, V_HEIGHT - UI_HEIGHT);
    }

    // é“è·¯æç”»
    function drawRoad() {
      const leftX = roadLeftX();
      const rightX = roadRightX();
      
      // é“è·¯æœ¬ä½“
      ctx.fillStyle = '#444';
      ctx.fillRect(Math.floor(leftX), UI_HEIGHT, Math.ceil(road.width), V_HEIGHT - UI_HEIGHT);
      
      // é“è·¯ç«¯ã®é»„ç·š
      ctx.fillStyle = '#ff0';
      ctx.fillRect(Math.floor(leftX), UI_HEIGHT, 4, V_HEIGHT - UI_HEIGHT);
      ctx.fillRect(Math.floor(rightX - 4), UI_HEIGHT, 4, V_HEIGHT - UI_HEIGHT);
      
      // ä¸­å¤®ç ´ç·šï¼ˆç™½ï¼‰
      ctx.fillStyle = '#fff';
      const centerX = Math.floor(leftX + road.width / 2 - 2);
      let y = road.centerLineY;
      
      // è¤‡æ•°ã®ç ´ç·šã‚’ç”»é¢å…¨ä½“ã«é…ç½®
      while (y < V_HEIGHT) {
        const drawY = Math.floor(y);
        const drawHeight = road.centerLineLength;
        
        // UIé ˜åŸŸã‚’é¿ã‘ã¦æç”»
        if (drawY + drawHeight > UI_HEIGHT && drawY < V_HEIGHT) {
          const startY = Math.max(drawY, UI_HEIGHT);
          const endY = Math.min(drawY + drawHeight, V_HEIGHT);
          const clippedHeight = endY - startY;
          
          if (clippedHeight > 0) {
            ctx.fillRect(centerX, startY, 4, clippedHeight);
          }
        }
        
        y += road.centerLineLength + road.centerLineGap;
      }
    }

    // éšœå®³ç‰©æç”»
    function drawObstacles() {
      for (const obs of game.obstacles) {
        // è»Šã®è‰²ã‚’çŠ¶æ…‹ã«å¿œã˜ã¦å¤‰ãˆã‚‹
        if (obs.isReverse) {
          ctx.fillStyle = '#f0f';  // é€†èµ°è»Šã¯ãƒã‚¼ãƒ³ã‚¿
        } else if (obs.laneChangeTarget !== null) {
          ctx.fillStyle = '#f80';  // è»Šç·šå¤‰æ›´ä¸­ã¯ã‚ªãƒ¬ãƒ³ã‚¸
        } else {
          ctx.fillStyle = '#c00';  // é€šå¸¸ã¯èµ¤
        }
        
        ctx.fillRect(
          Math.floor(obs.x - obs.width / 2),
          Math.floor(obs.y - obs.height / 2),
          Math.ceil(obs.width),
          Math.ceil(obs.height)
        );
        
        // çª“ã‚’æç”»
        ctx.fillStyle = '#fff';
        const windowSize = Math.min(obs.width, obs.height) * 0.3;
        ctx.fillRect(
          Math.floor(obs.x - windowSize / 2),
          Math.floor(obs.y - windowSize / 2),
          Math.ceil(windowSize),
          Math.ceil(windowSize)
        );
        
        // é€†èµ°è»Šã«ã¯è­¦å‘Šãƒãƒ¼ã‚¯
        if (obs.isReverse) {
          ctx.fillStyle = '#ff0';
          ctx.font = 'bold 20px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('!', obs.x, obs.y + 5);
        }
      }
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»
    function drawPlayer() {
      ctx.fillStyle = '#00f';
      ctx.fillRect(
        Math.floor(player.x - player.width / 2),
        Math.floor(player.y - player.height / 2),
        Math.ceil(player.width),
        Math.ceil(player.height)
      );
      
      // ãƒ˜ãƒƒãƒ‰ãƒ©ã‚¤ãƒˆ
      ctx.fillStyle = '#ff0';
      const lightSize = player.width * 0.2;
      ctx.fillRect(
        Math.floor(player.x - player.width / 3),
        Math.floor(player.y - player.height / 2 - 5),
        Math.ceil(lightSize),
        Math.ceil(lightSize)
      );
      ctx.fillRect(
        Math.floor(player.x + player.width / 3 - lightSize),
        Math.floor(player.y - player.height / 2 - 5),
        Math.ceil(lightSize),
        Math.ceil(lightSize)
      );
    }

    // UIæç”»
    function drawUI() {
      // UIèƒŒæ™¯
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, V_WIDTH, UI_HEIGHT);
      
      // ã‚¹ã‚³ã‚¢
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 32px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`ã‚¹ã‚³ã‚¢: ${game.score}`, 20, 50);
      
      // ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ¡ãƒ¼ã‚¿ãƒ¼ï¼ˆãƒ‡ã‚¸ã‚¿ãƒ«è¡¨ç¤ºï¼‰
      ctx.fillStyle = '#0f0';
      ctx.font = 'bold 40px Arial';
      ctx.textAlign = 'right';
      ctx.fillText(`${player.speedKmh} km/h`, V_WIDTH - 20, 55);
      
      // ãƒ©ã‚¤ãƒ•ãƒãƒ¼
      const barX = 20;
      const barY = UI_HEIGHT - 60;
      const barWidth = V_WIDTH - 40;
      const barHeight = 40;
      
      // ãƒ©ã‚¤ãƒ•ãƒãƒ¼èƒŒæ™¯
      ctx.fillStyle = '#333';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      // ãƒ©ã‚¤ãƒ•ãƒãƒ¼ï¼ˆç¾åœ¨å€¤ï¼‰
      const lifePercent = game.life / 100;
      const lifeColor = lifePercent > 0.5 ? '#0f0' : lifePercent > 0.25 ? '#ff0' : '#f00';
      ctx.fillStyle = lifeColor;
      ctx.fillRect(barX, barY, barWidth * lifePercent, barHeight);
      
      // ãƒ©ã‚¤ãƒ•æ 
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.strokeRect(barX, barY, barWidth, barHeight);
      
      // ãƒ©ã‚¤ãƒ•ãƒ†ã‚­ã‚¹ãƒˆ
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`æ–™ç†ã®å´©ã‚Œåº¦: ${Math.floor(game.life)}%`, V_WIDTH / 2, barY + 26);
    }

    // é€†èµ°è»Šã®è­¦å‘Šæç”»
    function drawReverseWarnings() {
      for (const warning of game.reverseWarnings) {
        // 200msã”ã¨ã«ç‚¹æ»…
        const shouldShow = Math.floor(warning.blinkTimer / 200) % 2 === 0;
        
        if (shouldShow) {
          const warningY = V_HEIGHT - 150;  // ç”»é¢ä¸‹éƒ¨ã«è¡¨ç¤º
          
          // èµ¤ã„â–¼ãƒãƒ¼ã‚¯
          ctx.fillStyle = '#f00';
          ctx.beginPath();
          ctx.moveTo(warning.x, warningY);
          ctx.lineTo(warning.x - 20, warningY - 30);
          ctx.lineTo(warning.x + 20, warningY - 30);
          ctx.closePath();
          ctx.fill();
          
          // è­¦å‘Šæ–‡å­—
          ctx.fillStyle = '#ff0';
          ctx.font = 'bold 18px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('!', warning.x, warningY - 10);
        }
      }
    }

    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
    function gameOver() {
      game.gameOver = true;
      document.getElementById('finalScore').textContent = `ã‚¹ã‚³ã‚¢: ${game.score}`;
      document.getElementById('gameOverScreen').style.display = 'flex';
    }

    // ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
    function resetGame() {
      game.score = 0;
      game.life = 100;
      game.gameOver = false;
      game.obstacles = [];
      game.reverseWarnings = [];
      game.nextSpawnTime = Date.now() + 2000;
      game.offRoadTimer = 0;
      game.speedMultiplier = 1;
      game.distanceTraveled = 0;
      
      player.x = V_WIDTH / 2;
      player.currentSpeed = 9;
      player.targetSpeed = 9;
      player.speedKmh = 60;
      road.curveCurrent = 0;
      road.curveTarget = 0;
      road.centerLineY = -200;  // ãƒªã‚»ãƒƒãƒˆæ™‚ã‚‚åˆæœŸä½ç½®ã‹ã‚‰
    }

    // ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
    let lastTime = 0;
    function gameLoop(timestamp) {
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;

      if (!game.started || game.gameOver) {
        requestAnimationFrame(gameLoop);
        return;
      }

      // æ›´æ–°
      updateRoadCurve();
      updatePlayer();
      updateObstacles(deltaTime);
      updateLife(deltaTime);
      updateScore();
      updateReverseWarnings(deltaTime);

      // æç”»
      drawBackground();
      drawRoad();
      drawObstacles();
      drawPlayer();
      drawReverseWarnings();
      drawUI();

      requestAnimationFrame(gameLoop);
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
    });

    document.addEventListener('keyup', e => {
      keys[e.key] = false;
    });

    // ã‚¿ãƒƒãƒæ“ä½œ
    const isTouchDevice = 'ontouchstart' in window;
    if (isTouchDevice) {
      document.getElementById('touchControls').classList.add('active');
    }

    document.getElementById('btnLeft').addEventListener('touchstart', e => {
      e.preventDefault();
      touchLeftActive = true;
    });

    document.getElementById('btnLeft').addEventListener('touchend', e => {
      e.preventDefault();
      touchLeftActive = false;
    });

    document.getElementById('btnRight').addEventListener('touchstart', e => {
      e.preventDefault();
      touchRightActive = true;
    });

    document.getElementById('btnRight').addEventListener('touchend', e => {
      e.preventDefault();
      touchRightActive = false;
    });

    document.getElementById('btnUp').addEventListener('touchstart', e => {
      e.preventDefault();
      touchUpActive = true;
    });

    document.getElementById('btnUp').addEventListener('touchend', e => {
      e.preventDefault();
      touchUpActive = false;
    });

    document.getElementById('btnDown').addEventListener('touchstart', e => {
      e.preventDefault();
      touchDownActive = true;
    });

    document.getElementById('btnDown').addEventListener('touchend', e => {
      e.preventDefault();
      touchDownActive = false;
    });

    // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³
    document.getElementById('btnStart').addEventListener('click', () => {
      document.getElementById('startScreen').style.display = 'none';
      game.started = true;
      game.nextSpawnTime = Date.now() + 2000;
      lastTime = performance.now();
    });

    // ãƒªã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³
    document.getElementById('btnRestart').addEventListener('click', () => {
      document.getElementById('gameOverScreen').style.display = 'none';
      resetGame();
      game.started = true;
      lastTime = performance.now();
    });

    // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—é–‹å§‹
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
