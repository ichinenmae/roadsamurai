// 逆走車の警告描画
    function drawReverseWarnings() {
      for (const warning of game.reverseWarnings) {
        // 200msごとに点滅
        const shouldShow = Math.floor(warning.blinkTimer / 200) % 2 === 0;
        
        if (shouldShow) {
          const warningY = V_HEIGHT - 150;  // 画面下部に表示
          
          // 赤い▼マーク
          ctx.fillStyle = '#f00';
          ctx.beginPath();
          ctx.moveTo(warning.x, warningY);
          ctx.lineTo(warning.x - 20, warningY - 30);
          ctx.lineTo(warning.x + 20, warningY - 30);
          ctx.closePath();
          ctx.fill();
          
          // 警告文字
          ctx.fillStyle = '#ff0';
          ctx.font = 'bold 18px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('!', warning.x, warningY - 10);
        }
      }
    }    // 逆走車の警告更新
    function updateReverseWarnings(deltaTime) {
      const now = Date.now();
      
      // 警告の点滅タイマー更新
      for (const warning of game.reverseWarnings) {
        warning.blinkTimer += deltaTime;
      }
      
      // 出現時刻を過ぎた警告を削除
      game.reverseWarnings = game.reverseWarnings.filter(w => w.spawnTime > now);
    }<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>フードデリバリーレース</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    body {
      width: 100%;
      height: 100%;
      position: fixed;
      top: 0;
      left: 0;
      overflow: hidden;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Arial', sans-serif;
      touch-action: none;
    }
    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      background: #87CEEB;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    #touchControls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      z-index: 1000;
    }
    #touchControls.active {
      display: grid;
      grid-template-columns: 80px 80px 80px;
      grid-template-rows: 80px 80px;
      gap: 20px;
      align-items: center;
      justify-items: center;
    }
    .touch-btn {
      width: 80px;
      height: 80px;
      background: rgba(255, 255, 255, 0.3);
      border: 3px solid rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      color: white;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      user-select: none;
      cursor: pointer;
      transition: background 0.1s;
    }
    .touch-btn:active {
      background: rgba(255, 255, 255, 0.5);
    }
    #btnUp {
      grid-column: 2;
      grid-row: 1;
    }
    #btnLeft {
      grid-column: 1;
      grid-row: 2;
    }
    #btnDown {
      grid-column: 2;
      grid-row: 2;
    }
    #btnRight {
      grid-column: 3;
      grid-row: 2;
    }
    #startScreen, #gameOverScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 2000;
    }
    #startScreen h1, #gameOverScreen h1 {
      font-size: 48px;
      margin-bottom: 20px;
      text-shadow: 0 4px 8px rgba(0,0,0,0.8);
    }
    #startScreen p, #gameOverScreen p {
      font-size: 20px;
      margin-bottom: 30px;
      text-align: center;
      padding: 0 20px;
    }
    .btn {
      padding: 15px 40px;
      font-size: 24px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: background 0.3s;
    }
    .btn:hover {
      background: #45a049;
    }
    .btn:active {
      transform: translateY(2px);
    }
    #gameOverScreen {
      display: none;
    }
    #finalScore {
      font-size: 36px;
      color: #FFD700;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="720" height="1280"></canvas>
  
  <div id="touchControls">
    <div class="touch-btn" id="btnUp">▲</div>
    <div class="touch-btn" id="btnLeft">◄</div>
    <div class="touch-btn" id="btnDown">▼</div>
    <div class="touch-btn" id="btnRight">►</div>
  </div>

  <div id="startScreen">
    <h1>🏍️ フードデリバリー</h1>
    <p>配達バイクを操作して障害物を避けよう！<br>道路から外れるとライフが減少します</p>
    <button class="btn" id="btnStart">スタート</button>
  </div>

  <div id="gameOverScreen">
    <h1>GAME OVER</h1>
    <div id="finalScore">スコア: 0</div>
    <button class="btn" id="btnRestart">リスタート</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const V_WIDTH = 720;
    const V_HEIGHT = 1280;
    
    // ゲーム状態
    const game = {
      score: 0,
      life: 100,
      gameOver: false,
      started: false,
      obstacles: [],
      nextSpawnTime: 0,
      offRoadTimer: 0,
      speedMultiplier: 1,
      distanceTraveled: 0,
      reverseWarnings: []  // 逆走車の出現予告
    };

    // プレイヤー設定
    const player = {
      x: V_WIDTH / 2,
      y: V_HEIGHT * 0.8,
      width: V_WIDTH * 0.11,
      height: V_HEIGHT * 0.125,
      speed: 6,
      moveLeft: false,
      moveRight: false,
      currentSpeed: 9,  // 現在の速度（ゲーム内速度）
      targetSpeed: 9,   // 目標速度
      speedKmh: 60,     // 表示用速度（km/h）
      acceleration: 0.15  // 加速度
    };

    // 道路設定
    const road = {
      width: V_WIDTH * 0.6,
      curveTarget: 0,
      curveCurrent: 0,
      centerLineY: -200,  // 初期位置を上にずらして自然に流れ始める
      centerLineGap: 100,
      centerLineLength: 200
    };

    // UI設定
    const UI_HEIGHT = V_HEIGHT * 0.2;

    // 障害物サイズ定義
    const obstacleTypes = [
      { probability: 0.70, width: player.width, height: player.height },
      { probability: 0.20, width: player.width * 0.5, height: player.height * 0.5 },
      { probability: 0.10, width: player.width, height: player.height * 2 }
    ];

    // 入力管理
    const keys = {};
    let touchLeftActive = false;
    let touchRightActive = false;
    let touchUpActive = false;
    let touchDownActive = false;

    // 道路左端X座標を計算
    function roadLeftX() {
      return (V_WIDTH - road.width) / 2 + road.curveCurrent;
    }

    // 道路右端X座標を計算
    function roadRightX() {
      return roadLeftX() + road.width;
    }

    // 障害物を道路内にクランプ
    function clampObstacleX(obs) {
      const margin = road.width * 0.05;
      const leftBound = roadLeftX() + margin;
      const rightBound = roadRightX() - margin;
      
      obs.x = Math.max(leftBound + obs.width / 2, Math.min(rightBound - obs.width / 2, obs.x));
    }

    // 障害物生成（逆走車の予告付き）
    function spawnObstacle() {
      const rand = Math.random();
      let cumProb = 0;
      let chosenType = obstacleTypes[0];
      
      for (const type of obstacleTypes) {
        cumProb += type.probability;
        if (rand <= cumProb) {
          chosenType = type;
          break;
        }
      }

      // 速度設定（道路基準速度の50%, +25%, -25%）
      const baseSpeed = 4 * game.speedMultiplier;
      const speedRand = Math.random();
      let speed;
      if (speedRand < 0.5) speed = baseSpeed;
      else if (speedRand < 0.75) speed = baseSpeed + 2;
      else speed = baseSpeed - 2;

      const willBeReverse = Math.random() < 0.07;  // 逆走車判定を先に

      const obs = {
        x: roadLeftX() + road.width / 2,
        y: willBeReverse ? V_HEIGHT + chosenType.height + 100 : -chosenType.height - 100,
        width: chosenType.width,
        height: chosenType.height,
        speed: willBeReverse ? -(Math.abs(speed) + 3) : Math.max(2, speed),
        canChangeLane: !willBeReverse && Math.random() < 0.15,
        laneChangeTarget: null,
        laneChangeSpeed: 0,
        isReverse: willBeReverse
      };

      // 重なり回避（最大30回試行）
      let attempts = 0;
      let valid = false;
      
      while (attempts < 30 && !valid) {
        // ランダムな位置を生成
        obs.x = roadLeftX() + road.width * (0.2 + Math.random() * 0.6);
        clampObstacleX(obs);
        
        valid = true;
        
        // 既存の全障害物との重なりチェック（同じ方向の車のみ）
        for (const other of game.obstacles) {
          // 逆走車は逆走車同士のみ、通常車は通常車同士のみチェック
          if (obs.isReverse !== other.isReverse) continue;
          
          // Y軸方向の距離チェック
          const verticalDistance = Math.abs(obs.y - other.y);
          const minVerticalGap = Math.max(obs.height, other.height) * 2.0;
          
          if (verticalDistance < minVerticalGap) {
            // 水平方向の距離もチェック
            const horizontalDistance = Math.abs(obs.x - other.x);
            const minHorizontalGap = (obs.width + other.width) / 2 + 30;
            
            if (horizontalDistance < minHorizontalGap) {
              valid = false;
              break;
            }
          }
          
          // 通常の当たり判定でもチェック
          if (isCollidingEnemyEnemy(obs, other)) {
            valid = false;
            break;
          }
        }
        attempts++;
      }

      // 有効な位置が見つかった場合のみ追加
      if (valid) {
        // 逆走車の場合は1秒前に予告を追加
        if (obs.isReverse) {
          game.reverseWarnings.push({
            x: obs.x,
            spawnTime: Date.now() + 1000,  // 1秒後に出現
            blinkTimer: 0
          });
          // 実際の車は1秒後に追加（タイマーで管理）
          setTimeout(() => {
            game.obstacles.push(obs);
          }, 1000);
        } else {
          // 通常車は即座に追加
          game.obstacles.push(obs);
        }
      }
    }

    // プレイヤーと障害物の当たり判定（スケール0.85 - 小さめ）
    function isCollidingPlayerEnemy(p, e) {
      const scale = 0.85;
      const pw = p.width * scale;
      const ph = p.height * scale;
      const ew = e.width * scale;
      const eh = e.height * scale;
      
      return !(
        p.x + pw / 2 < e.x - ew / 2 ||
        p.x - pw / 2 > e.x + ew / 2 ||
        p.y + ph / 2 < e.y - eh / 2 ||
        p.y - ph / 2 > e.y + eh / 2
      );
    }

    // 障害物同士の当たり判定（スケール1.3 - 大きめ）
    function isCollidingEnemyEnemy(a, b) {
      const scale = 1.3;  // 1.15から1.3に拡大
      const aw = a.width * scale;
      const ah = a.height * scale;
      const bw = b.width * scale;
      const bh = b.height * scale;
      
      return !(
        a.x + aw / 2 < b.x - bw / 2 ||
        a.x - aw / 2 > b.x + bw / 2 ||
        a.y + ah / 2 < b.y - bh / 2 ||
        a.y - ah / 2 > b.y + bh / 2
      );
    }

    // プレイヤーが道路上にいるか判定
    function isPlayerOnRoad() {
      const leftBound = roadLeftX();
      const rightBound = roadRightX();
      const playerLeft = player.x - player.width / 2;
      const playerRight = player.x + player.width / 2;
      
      return playerRight > leftBound && playerLeft < rightBound;
    }

    // 逆走車の警告更新
    function updateReverseWarnings(deltaTime) {
      const now = Date.now();
      
      // 警告の点滅タイマー更新
      for (const warning of game.reverseWarnings) {
        warning.blinkTimer += deltaTime;
      }
      
      // 出現時刻を過ぎた警告を削除
      game.reverseWarnings = game.reverseWarnings.filter(w => w.spawnTime > now);
    }

    // 道路カーブ更新
    function updateRoadCurve() {
      // ランダムにターゲット変更
      if (Math.random() < 0.01) {
        road.curveTarget = (Math.random() - 0.5) * V_WIDTH * 0.4;
      }
      
      // スムーズに追従
      road.curveCurrent += (road.curveTarget - road.curveCurrent) * 0.02;
      
      // 道路が画面外に出ないよう制限
      const maxCurve = V_WIDTH * 0.15;
      road.curveCurrent = Math.max(-maxCurve, Math.min(maxCurve, road.curveCurrent));
      
      // 中央線アニメーション
      road.centerLineY += 12 * game.speedMultiplier;  // 8 * 1.5 = 12
      if (road.centerLineY > road.centerLineLength + road.centerLineGap) {
        road.centerLineY = 0;
      }
    }

    // 障害物更新
    function updateObstacles(deltaTime) {
      // プレイヤー速度に基づく相対速度計算
      const speedRatio = player.currentSpeed / 9;  // 巡航速度(9)を基準
      
      // 移動
      for (const obs of game.obstacles) {
        obs.y += obs.speed * game.speedMultiplier * speedRatio;
        
        // 車線変更処理（逆走車は車線変更しない）
        if (obs.canChangeLane && !obs.isReverse) {
          // 画面内に入ってからランダムで車線変更を開始
          if (obs.y > 100 && obs.y < V_HEIGHT - 300 && obs.laneChangeTarget === null && Math.random() < 0.005) {
            // 左右どちらかにランダムで移動
            const direction = Math.random() < 0.5 ? -1 : 1;
            const changeAmount = road.width * 0.25 * direction;
            obs.laneChangeTarget = obs.x + changeAmount;
            obs.laneChangeSpeed = 2;  // 車線変更速度
          }
          
          // 車線変更実行
          if (obs.laneChangeTarget !== null) {
            const diff = obs.laneChangeTarget - obs.x;
            if (Math.abs(diff) < obs.laneChangeSpeed) {
              obs.x = obs.laneChangeTarget;
              obs.laneChangeTarget = null;
            } else {
              obs.x += Math.sign(diff) * obs.laneChangeSpeed;
            }
          }
        }
        
        // 道路カーブに追従
        const roadCenter = roadLeftX() + road.width / 2;
        obs.x += (roadCenter - (roadLeftX() + road.width / 2)) * 0.5;
        clampObstacleX(obs);
      }

      // 障害物同士の衝突回避（速度調整）- 画面内外両方で判定
      for (let i = 0; i < game.obstacles.length; i++) {
        for (let j = i + 1; j < game.obstacles.length; j++) {
          const a = game.obstacles[i];
          const b = game.obstacles[j];
          
          // 当たり判定での接触チェック（スケール1.3で大きめに判定）
          // 逆走車同士または逆走車と通常車は衝突判定しない
          if (isCollidingEnemyEnemy(a, b) && !(a.isReverse || b.isReverse)) {
            // 下側（後続）の障害物を上側（先行）の速度に合わせる
            if (a.y > b.y) {
              a.speed = b.speed;  // aが下側なのでbの速度に合わせる
            } else if (b.y > a.y) {
              b.speed = a.speed;  // bが下側なのでaの速度に合わせる
            }
          }
          
          // 画面外での追加の距離調整（逆走車は除外）
          if ((a.y < 0 || b.y < 0) && !(a.isReverse || b.isReverse)) {
            const verticalDistance = Math.abs(a.y - b.y);
            const horizontalDistance = Math.abs(a.x - b.x);
            const minGap = Math.max(a.height, b.height) * 1.5;
            
            if (verticalDistance < minGap && horizontalDistance < road.width * 0.5) {
              // 下側の車を減速
              if (a.y > b.y) {
                a.speed = Math.max(1, b.speed - 0.5);
              } else {
                b.speed = Math.max(1, a.speed - 0.5);
              }
            }
          }
        }
      }

      // プレイヤーとの衝突判定（速度によってダメージ変化）
      for (const obs of game.obstacles) {
        if (isCollidingPlayerEnemy(player, obs)) {
          // 速度によってダメージを変更
          let damage = 50;  // デフォルト（巡航）
          if (player.speedKmh >= 80) {
            damage = 75;  // 高速
          } else if (player.speedKmh <= 40) {
            damage = 25;  // 低速・停止
          }
          
          game.life = Math.max(0, game.life - damage);
          // 衝突した障害物を削除
          game.obstacles = game.obstacles.filter(o => o !== obs);
          
          if (game.life <= 0) {
            gameOver();
          }
          break;
        }
      }

      // 画面外の障害物を削除（逆走車も考慮）
      game.obstacles = game.obstacles.filter(obs => {
        if (obs.isReverse) {
          // 逆走車は画面上に消えたら削除
          return obs.y > -obs.height - 100;
        } else {
          // 通常車は上下両方で削除
          return obs.y > -300 && obs.y < V_HEIGHT + obs.height;
        }
      });

      // 新規生成
      const now = Date.now();
      if (now >= game.nextSpawnTime && game.obstacles.length < 4) {
        // 画面外の通常車と逆走車をそれぞれカウント
        const offscreenNormal = game.obstacles.filter(o => !o.isReverse && o.y < 0).length;
        const offscreenReverse = game.obstacles.filter(o => o.isReverse && o.y > V_HEIGHT).length;
        
        // 通常車は画面外に2台未満、逆走車は1台未満なら生成可能
        if (offscreenNormal < 2 || offscreenReverse < 1) {
          spawnObstacle();
        }
        
        const spawnIntervals = [1500, 2500, 4000];  // 間隔を少し広げる
        const nextInterval = spawnIntervals[Math.floor(Math.random() * spawnIntervals.length)];
        game.nextSpawnTime = now + Math.max(1500, nextInterval);
      }
    }

    // プレイヤー更新
    function updatePlayer() {
      // 速度変更入力
      if (keys['ArrowUp'] || touchUpActive) {
        // 加速（次の段階へ）
        if (player.targetSpeed === 0) player.targetSpeed = 6;
        else if (player.targetSpeed === 6) player.targetSpeed = 9;
        else if (player.targetSpeed === 9) player.targetSpeed = 12;
      }
      if (keys['ArrowDown'] || touchDownActive) {
        // 減速（前の段階へ）
        if (player.targetSpeed === 12) player.targetSpeed = 9;
        else if (player.targetSpeed === 9) player.targetSpeed = 6;
        else if (player.targetSpeed === 6) player.targetSpeed = 0;
      }
      
      // 速度を目標に向けて連続的に変化
      if (player.currentSpeed < player.targetSpeed) {
        player.currentSpeed = Math.min(player.targetSpeed, player.currentSpeed + player.acceleration);
      } else if (player.currentSpeed > player.targetSpeed) {
        player.currentSpeed = Math.max(player.targetSpeed, player.currentSpeed - player.acceleration);
      }
      
      // km/h表示用に変換
      if (player.currentSpeed >= 11.5) player.speedKmh = 80;
      else if (player.currentSpeed >= 7.5) player.speedKmh = Math.round((player.currentSpeed / 9) * 60);
      else if (player.currentSpeed >= 3) player.speedKmh = Math.round((player.currentSpeed / 6) * 40);
      else if (player.currentSpeed > 0) player.speedKmh = Math.round((player.currentSpeed / 6) * 40);
      else player.speedKmh = 0;
      
      // 左右移動
      if (keys['ArrowLeft'] || touchLeftActive) {
        player.x -= player.speed;
      }
      if (keys['ArrowRight'] || touchRightActive) {
        player.x += player.speed;
      }

      // プレイヤーを画面内に制限
      const minX = V_WIDTH * 0.05 + player.width / 2;
      const maxX = V_WIDTH * 0.95 - player.width / 2;
      player.x = Math.max(minX, Math.min(maxX, player.x));
    }

    // ライフ更新
    function updateLife(deltaTime) {
      if (!isPlayerOnRoad()) {
        game.offRoadTimer += deltaTime;
        if (game.offRoadTimer >= 100) {
          game.life = Math.max(0, game.life - 1);
          game.offRoadTimer = 0;
          
          if (game.life <= 0) {
            gameOver();
          }
        }
      } else {
        game.offRoadTimer = 0;
      }
    }

    // スコア更新
    function updateScore() {
      game.score += 1;
      game.distanceTraveled += 1;
      
      // 難易度上昇
      if (game.distanceTraveled % 1000 === 0) {
        game.speedMultiplier = Math.min(2.0, game.speedMultiplier + 0.1);
      }
    }

    // 背景描画
    function drawBackground() {
      // 空
      ctx.fillStyle = '#87CEEB';
      ctx.fillRect(0, 0, V_WIDTH, V_HEIGHT);
      
      // 地面（道路外）
      ctx.fillStyle = '#2d5016';
      ctx.fillRect(0, UI_HEIGHT, V_WIDTH, V_HEIGHT - UI_HEIGHT);
    }

    // 道路描画
    function drawRoad() {
      const leftX = roadLeftX();
      const rightX = roadRightX();
      
      // 道路本体
      ctx.fillStyle = '#444';
      ctx.fillRect(Math.floor(leftX), UI_HEIGHT, Math.ceil(road.width), V_HEIGHT - UI_HEIGHT);
      
      // 道路端の黄線
      ctx.fillStyle = '#ff0';
      ctx.fillRect(Math.floor(leftX), UI_HEIGHT, 4, V_HEIGHT - UI_HEIGHT);
      ctx.fillRect(Math.floor(rightX - 4), UI_HEIGHT, 4, V_HEIGHT - UI_HEIGHT);
      
      // 中央破線（白）
      ctx.fillStyle = '#fff';
      const centerX = Math.floor(leftX + road.width / 2 - 2);
      let y = road.centerLineY;
      
      // 複数の破線を画面全体に配置
      while (y < V_HEIGHT) {
        const drawY = Math.floor(y);
        const drawHeight = road.centerLineLength;
        
        // UI領域を避けて描画
        if (drawY + drawHeight > UI_HEIGHT && drawY < V_HEIGHT) {
          const startY = Math.max(drawY, UI_HEIGHT);
          const endY = Math.min(drawY + drawHeight, V_HEIGHT);
          const clippedHeight = endY - startY;
          
          if (clippedHeight > 0) {
            ctx.fillRect(centerX, startY, 4, clippedHeight);
          }
        }
        
        y += road.centerLineLength + road.centerLineGap;
      }
    }

    // 障害物描画
    function drawObstacles() {
      for (const obs of game.obstacles) {
        // 車の色を状態に応じて変える
        if (obs.isReverse) {
          ctx.fillStyle = '#f0f';  // 逆走車はマゼンタ
        } else if (obs.laneChangeTarget !== null) {
          ctx.fillStyle = '#f80';  // 車線変更中はオレンジ
        } else {
          ctx.fillStyle = '#c00';  // 通常は赤
        }
        
        ctx.fillRect(
          Math.floor(obs.x - obs.width / 2),
          Math.floor(obs.y - obs.height / 2),
          Math.ceil(obs.width),
          Math.ceil(obs.height)
        );
        
        // 窓を描画
        ctx.fillStyle = '#fff';
        const windowSize = Math.min(obs.width, obs.height) * 0.3;
        ctx.fillRect(
          Math.floor(obs.x - windowSize / 2),
          Math.floor(obs.y - windowSize / 2),
          Math.ceil(windowSize),
          Math.ceil(windowSize)
        );
        
        // 逆走車には警告マーク
        if (obs.isReverse) {
          ctx.fillStyle = '#ff0';
          ctx.font = 'bold 20px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('!', obs.x, obs.y + 5);
        }
      }
    }

    // プレイヤー描画
    function drawPlayer() {
      ctx.fillStyle = '#00f';
      ctx.fillRect(
        Math.floor(player.x - player.width / 2),
        Math.floor(player.y - player.height / 2),
        Math.ceil(player.width),
        Math.ceil(player.height)
      );
      
      // ヘッドライト
      ctx.fillStyle = '#ff0';
      const lightSize = player.width * 0.2;
      ctx.fillRect(
        Math.floor(player.x - player.width / 3),
        Math.floor(player.y - player.height / 2 - 5),
        Math.ceil(lightSize),
        Math.ceil(lightSize)
      );
      ctx.fillRect(
        Math.floor(player.x + player.width / 3 - lightSize),
        Math.floor(player.y - player.height / 2 - 5),
        Math.ceil(lightSize),
        Math.ceil(lightSize)
      );
    }

    // UI描画
    function drawUI() {
      // UI背景
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, V_WIDTH, UI_HEIGHT);
      
      // スコア
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 32px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`スコア: ${game.score}`, 20, 50);
      
      // スピードメーター（デジタル表示）
      ctx.fillStyle = '#0f0';
      ctx.font = 'bold 40px Arial';
      ctx.textAlign = 'right';
      ctx.fillText(`${player.speedKmh} km/h`, V_WIDTH - 20, 55);
      
      // ライフバー
      const barX = 20;
      const barY = UI_HEIGHT - 60;
      const barWidth = V_WIDTH - 40;
      const barHeight = 40;
      
      // ライフバー背景
      ctx.fillStyle = '#333';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      // ライフバー（現在値）
      const lifePercent = game.life / 100;
      const lifeColor = lifePercent > 0.5 ? '#0f0' : lifePercent > 0.25 ? '#ff0' : '#f00';
      ctx.fillStyle = lifeColor;
      ctx.fillRect(barX, barY, barWidth * lifePercent, barHeight);
      
      // ライフ枠
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.strokeRect(barX, barY, barWidth, barHeight);
      
      // ライフテキスト
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`料理の崩れ度: ${Math.floor(game.life)}%`, V_WIDTH / 2, barY + 26);
    }

    // 逆走車の警告描画
    function drawReverseWarnings() {
      for (const warning of game.reverseWarnings) {
        // 200msごとに点滅
        const shouldShow = Math.floor(warning.blinkTimer / 200) % 2 === 0;
        
        if (shouldShow) {
          const warningY = V_HEIGHT - 150;  // 画面下部に表示
          
          // 赤い▼マーク
          ctx.fillStyle = '#f00';
          ctx.beginPath();
          ctx.moveTo(warning.x, warningY);
          ctx.lineTo(warning.x - 20, warningY - 30);
          ctx.lineTo(warning.x + 20, warningY - 30);
          ctx.closePath();
          ctx.fill();
          
          // 警告文字
          ctx.fillStyle = '#ff0';
          ctx.font = 'bold 18px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('!', warning.x, warningY - 10);
        }
      }
    }

    // ゲームオーバー
    function gameOver() {
      game.gameOver = true;
      document.getElementById('finalScore').textContent = `スコア: ${game.score}`;
      document.getElementById('gameOverScreen').style.display = 'flex';
    }

    // ゲームリセット
    function resetGame() {
      game.score = 0;
      game.life = 100;
      game.gameOver = false;
      game.obstacles = [];
      game.reverseWarnings = [];
      game.nextSpawnTime = Date.now() + 2000;
      game.offRoadTimer = 0;
      game.speedMultiplier = 1;
      game.distanceTraveled = 0;
      
      player.x = V_WIDTH / 2;
      player.currentSpeed = 9;
      player.targetSpeed = 9;
      player.speedKmh = 60;
      road.curveCurrent = 0;
      road.curveTarget = 0;
      road.centerLineY = -200;  // リセット時も初期位置から
    }

    // メインループ
    let lastTime = 0;
    function gameLoop(timestamp) {
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;

      if (!game.started || game.gameOver) {
        requestAnimationFrame(gameLoop);
        return;
      }

      // 更新
      updateRoadCurve();
      updatePlayer();
      updateObstacles(deltaTime);
      updateLife(deltaTime);
      updateScore();
      updateReverseWarnings(deltaTime);

      // 描画
      drawBackground();
      drawRoad();
      drawObstacles();
      drawPlayer();
      drawReverseWarnings();
      drawUI();

      requestAnimationFrame(gameLoop);
    }

    // イベントリスナー
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
    });

    document.addEventListener('keyup', e => {
      keys[e.key] = false;
    });

    // タッチ操作
    const isTouchDevice = 'ontouchstart' in window;
    if (isTouchDevice) {
      document.getElementById('touchControls').classList.add('active');
    }

    document.getElementById('btnLeft').addEventListener('touchstart', e => {
      e.preventDefault();
      touchLeftActive = true;
    });

    document.getElementById('btnLeft').addEventListener('touchend', e => {
      e.preventDefault();
      touchLeftActive = false;
    });

    document.getElementById('btnRight').addEventListener('touchstart', e => {
      e.preventDefault();
      touchRightActive = true;
    });

    document.getElementById('btnRight').addEventListener('touchend', e => {
      e.preventDefault();
      touchRightActive = false;
    });

    document.getElementById('btnUp').addEventListener('touchstart', e => {
      e.preventDefault();
      touchUpActive = true;
    });

    document.getElementById('btnUp').addEventListener('touchend', e => {
      e.preventDefault();
      touchUpActive = false;
    });

    document.getElementById('btnDown').addEventListener('touchstart', e => {
      e.preventDefault();
      touchDownActive = true;
    });

    document.getElementById('btnDown').addEventListener('touchend', e => {
      e.preventDefault();
      touchDownActive = false;
    });

    // スタートボタン
    document.getElementById('btnStart').addEventListener('click', () => {
      document.getElementById('startScreen').style.display = 'none';
      game.started = true;
      game.nextSpawnTime = Date.now() + 2000;
      lastTime = performance.now();
    });

    // リスタートボタン
    document.getElementById('btnRestart').addEventListener('click', () => {
      document.getElementById('gameOverScreen').style.display = 'none';
      resetGame();
      game.started = true;
      lastTime = performance.now();
    });

    // ゲームループ開始
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
